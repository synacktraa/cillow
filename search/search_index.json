{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"pipuv <pre><code>pip install cillow\n</code></pre> <pre><code>uv pip install cillow\n</code></pre>"},{"location":"#what-is-cillow","title":"What is Cillow?","text":"<p>Cillow is an open-source library that enables you to execute AI-generated code in a controlled environment. The name \"Cillow\" follows the same naming convention as \"Pillow\" (Python Imaging Library), representing its role as a Code Interpreter Library.</p> <p>It offers key features such as:</p> <ul> <li>Environment Switching: Effortlessly switch between multiple Python environments.</li> <li>Automated Package Installation: Automatically install imported packages using <code>uv</code> or <code>pip</code>.</li> <li>Functionality Patches: Apply patches to restrict the scope of AI-generated code, capture outputs such as <code>stdout</code>, <code>stderr</code>, images, plots, and more.</li> </ul> <p> Star the Repo  Quickstart  Cookbooks</p>"},{"location":"sandboxing_the_server/","title":"Sandboxing The Server","text":"<p>This guide will show you how to securely host the Cillow server using Docker, leveraging the Cillow base image for isolated and consistent deployments.</p>"},{"location":"sandboxing_the_server/#1-prerequisites","title":"1. Prerequisites","text":"<ul> <li>Docker installed on your system</li> <li>A <code>server.py</code> file to configure and run the Cillow server. This file sets up and starts the server, optionally with custom patches or configurations (see Using Cillow guide).</li> </ul>"},{"location":"sandboxing_the_server/#2-creating-the-dockerfile","title":"2. Creating the Dockerfile","text":"<p>Create a <code>Dockerfile</code> in the same directory as your <code>server.py</code> file:</p> <pre><code>FROM synacktra/cillow:latest\n\n# Uncomment the following line if you want cillow to use uv for package installation\n# COPY --from=ghcr.io/astral-sh/uv:latest /uv /bin/uv\n\nWORKDIR /app\n\n# Copy your server script into the container\nCOPY server.py .\n\n# Expose the port the server will listen on\nEXPOSE 5556\n\n# Define the command to start the server\nCMD [\"python\", \"server.py\"]\n</code></pre>"},{"location":"sandboxing_the_server/#3-building-the-docker-image","title":"3. Building the Docker Image","text":"<p>Run the following command to build the Docker image. The <code>-t</code> flag tags the image as <code>cillow-server</code>:</p> <pre><code>docker build -t cillow-server .\n</code></pre>"},{"location":"sandboxing_the_server/#4-running-the-docker-container","title":"4. Running the Docker Container","text":"<p>Launch the container using the built image. The <code>--init</code> flag ensures proper process handling, and <code>-it</code> keeps the container interactive:</p> <pre><code>docker run --init -it -p 5556:5556 --name cillow-server cillow-server\n</code></pre> <p>This maps port <code>5556</code> from the container to your local machine, enabling client connections.</p>"},{"location":"sandboxing_the_server/#5-accessing-the-sandboxed-server","title":"5. Accessing the Sandboxed Server","text":"<p>Once the container is running, the Cillow server will be available at <code>localhost:5556</code>. Use <code>cillow.Client</code> to interact with the server as explained in the Using Cillow guide.</p>"},{"location":"sandboxing_the_server/#6-customizing-your-server","title":"6. Customizing Your Server","text":"<p>Enhance your server with additional features by: - Adding custom patches - Configuring interpreter limits or other server parameters</p> <p>Simply modify your <code>server.py</code>, rebuild the Docker image, and restart the container with updated settings.</p>"},{"location":"supported_languages/","title":"Supported Languages","text":"<p>At the moment, Cillow only supports Python, as it does not rely on Jupyter Kernel/Lab.</p> <p>This project began as an exploration of E2B's code interpreter. I implemented the Python interpreter from scratch, taking a different approach by adding features like environment switching and functionality patching. Recognizing the potential of the project, I expanded it into a client-server architecture using ZeroMQ, threading, and multiprocessing.</p>"},{"location":"quickstart/connecting_LLM_%26_Frameworks/","title":"Connecting LLMs & Frameworks","text":"<p>Cillow can be used with any LLM or AI framework.</p>"},{"location":"quickstart/connecting_LLM_%26_Frameworks/#contents","title":"Contents","text":"<ul> <li>LiteLLM</li> <li>CrewAI</li> <li>LlamaIndex</li> <li>LangChain</li> </ul>"},{"location":"quickstart/connecting_LLM_%26_Frameworks/#litellm","title":"LiteLLM","text":"<p>Call all LLM APIs using the OpenAI format [Bedrock, Huggingface, VertexAI, TogetherAI, Azure, OpenAI, Groq etc.] through LiteLLM</p> <pre><code># pip install litellm cillow\nimport cillow\nfrom litellm import completion\n\nINSTRUCTION = \"You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks.\"\n\nresponse = completion(\n    model=\"groq/llama-3.3-70b-versatile\",\n    messages=[\n        {\"role\": \"system\", \"content\": INSTRUCTION},\n        {\"role\": \"user\", \"content\": \"Calculate how many 'r's are in the word 'strawberry'.\"}\n    ],\n)\ncode: str = response.choices[0].message.content\nif code:\n    print(code)\n    with cillow.Client.new() as client:\n        print(client.run_code(code))\n</code></pre>"},{"location":"quickstart/connecting_LLM_%26_Frameworks/#crewai","title":"CrewAI","text":"<p>CrewAI is a platform for building AI agents.</p> <pre><code># pip install crewai crewai[tools] cillow\nfrom crewai import Agent, Task, Crew, LLM\nfrom crewai.tools import tool\n\n@tool(\"Python interpreter tool\")\ndef execute_python(code: str):\n    \"\"\"\n    Execute Python code and return the results.\n    \"\"\"\n    with cillow.Client.new() as client:\n        return client.run_code(code)\n\n# Define the agent\npython_executor = Agent(\n    role='Python Executor',\n    goal='Execute Python code and return the results',\n    backstory=\"You are a helpful assistant that can execute python code in a Jupyter notebook.\",\n    tools=[execute_python],\n    llm=LLM(model=\"groq/llama-3.3-70b-versatile\")\n)\n\n# Define the task\nexecute_task = Task(\n    description=\"Calculate how many r's are in the word 'strawberry'\",\n    agent=python_executor,\n    expected_output=\"The number of r's in the word 'strawberry'\"\n)\n\n# Create the crew\ncode_execution_crew = Crew(\n    agents=[python_executor],\n    tasks=[execute_task],\n    verbose=True,\n)\n\n# Run the crew\nresult = code_execution_crew.kickoff()\nprint(result)\n</code></pre>"},{"location":"quickstart/connecting_LLM_%26_Frameworks/#llamaindex","title":"LlamaIndex","text":"<p>LlamaIndex is a data framework for your LLM applications</p> <pre><code># pip install llama-index cillow\nfrom llama_index.core.tools import FunctionTool\nfrom llama_index.llms.groq import Groq\nfrom llama_index.core.agent import ReActAgent\n\n# Define the tool\ndef execute_python(code: str):\n    with cillow.Client.new() as client:\n        return client.run_code(code)\n\ncillow_interpreter_tool = FunctionTool.from_defaults(\n    name=\"execute_python\",\n    description=\"Execute python code in a Jupyter notebook cell and return result\",\n    fn=execute_python\n)\n\n# Initialize LLM\nllm = Groq(model=\"llama-3.3-70b-versatile\")\n\n# Initialize ReAct agent\nagent = ReActAgent.from_tools([cillow_interpreter_tool], llm=llm, verbose=True)\nagent.chat(\"Calculate how many r's are in the word 'strawberry'\")\n</code></pre>"},{"location":"quickstart/connecting_LLM_%26_Frameworks/#langchain","title":"LangChain","text":"<p>Build context-aware reasoning applications with LangChain</p> <pre><code># pip install langchain langchain-groq cillow\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_core.tools import tool\nfrom langchain.agents import create_tool_calling_agent, AgentExecutor\nfrom langchain_groq import ChatGroq\n\nINSTRUCTION = \"You are a helpful assistant that can execute python code in a Jupyter notebook.\"\n\n# Define the tool\n@tool\ndef execute_python(code: str):\n    \"\"\"\n    Execute python code in a Jupyter notebook.\n    \"\"\"\n    with cillow.Client.new() as client:\n        return client.run_code(code)\n\n# Define LangChain components\nprompt_template = ChatPromptTemplate.from_messages([\n    (\"system\", INSTRUCTION),\n    (\"human\", \"{input}\"),\n    (\"placeholder\", \"{agent_scratchpad}\"),\n])\n\ntools = [execute_python]\nllm = ChatGroq(model=\"llama-3.3-70b-versatile\", temperature=0)\n\nagent = create_tool_calling_agent(llm, tools, prompt_template)\nagent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)\n\n# Run the agent\nagent_executor.invoke({\"input\": \"Calculate how many r's are in the word 'strawberry'\"})\n</code></pre>"},{"location":"quickstart/custom_patches/","title":"Custom Patches","text":"<p>This guide will show you how to write custom patches for your own use cases.</p> <p>Cillow comes with prebuilt patches to capture real-time streaming outputs generated during code execution so they can be redirected to the client when added. Currently, the following patches are available:</p> <ul> <li><code>patch_stdout_stderr_write</code>: Captures <code>sys.stdout</code> and <code>sys.stderr</code> writes.</li> <li><code>patch_matplotlib_pyplot_show</code>: Captures <code>matplotlib.pyplot.show()</code> calls.</li> <li><code>patch_pillow_show</code>: Captures <code>PIL.Image.show()</code> calls.</li> </ul> <p>Cillow does not add the prebuilt patches by default. You need to add them explicitly. This provides more flexibility and control if you wish to process those streams in a different way.</p>"},{"location":"quickstart/custom_patches/#writing-your-own-patches","title":"Writing Your Own Patches","text":"<p>Any callable can be patched, whether it is a function, class, or method.</p> <pre><code>from contextlib import contextmanager\nimport os\n\nimport cillow\n\nos_system_switchable = cillow.Switchable(os.system)\n\n@contextmanager\ndef patch_os_system():\n    def disabled_os_system(command: str):\n        return \"os.system has been disabled.\"\n\n    with os_system_switchable.switch_to(disabled_os_system):\n        yield\n</code></pre> <pre><code>with patch_os_system():\n    print(os.system(\"echo hello\"))\n</code></pre> <p>Output</p> <pre><code>os.system has been disabled.\n</code></pre> <p>It is recommended to avoid fully disabling functionality, as it might be needed elsewhere for actual operations. Instead, modify the functionality based on your specific use case.</p> <p>For example, if you want to disable functionality only for certain inputs, you can add conditional checks instead of disabling the entire functionality:</p> <pre><code>os_system_switchable = cillow.Switchable(os.system)\n\n@contextmanager\ndef patch_os_system():\n    def ignore_rm_command(command: str):\n        if command.startswith(\"rm\"):\n            return \"rm commands are blocked.\"\n        return os_system_switchable.original(command)\n\n    with os_system_switchable.switch_to(ignore_rm_command):\n        yield\n</code></pre> <p>Important</p> <p>Avoid directly invoking the patched callable within a patch function, as it can cause an infinite loop.</p> <p>Instead, use the <code>original</code> method of the <code>Switchable</code> instance to access the original functionality.</p> <p>Example: In the example above, we used <code>os_system_switchable.original</code> instead of <code>os.system</code> to call the original <code>os.system</code> function.</p> <pre><code>with patch_os_system():\n    print(os.system(\"echo hello\"))\n    print(os.system(\"rm -rf /\"))\n</code></pre> <p>Output</p> <pre><code>hello\n0  # os.system returns 0 for successful execution\nrm commands are blocked.\n</code></pre> <p>Refer to the Switchable component to learn how it works internally.</p>"},{"location":"quickstart/custom_patches/#adding-patches","title":"Adding Patches","text":"<pre><code>cillow.add_patches(patch_os_system)\n</code></pre>"},{"location":"quickstart/custom_patches/#clearing-patches","title":"Clearing Patches","text":"<pre><code>cillow.clear_patches()\n</code></pre>"},{"location":"quickstart/using_cillow/","title":"Using Cillow","text":"<p>This guide will show you how to host a server and connect to it from a client.</p>"},{"location":"quickstart/using_cillow/#running-a-cillow-server","title":"Running a Cillow Server","text":"<p>We\u2019ll write minimal code to run a Cillow server with prebuilt patches.</p> <p>Prebuilt patches include those that capture real-time streaming outputs generated during code execution so they can be redirected to the client. Currently, the following patches are available:</p> <ul> <li><code>patch_stdout_stderr_write</code>: Captures <code>sys.stdout</code> and <code>sys.stderr</code> writes.</li> <li><code>patch_matplotlib_pyplot_show</code>: Captures <code>matplotlib.pyplot.show()</code> calls.</li> <li><code>patch_pillow_show</code>: Captures <code>PIL.Image.show()</code> calls.</li> </ul> <p>Learn about writing custom patches here.</p> <pre><code>import cillow\n\ncillow.add_patches(\n    cillow.prebuilt_patches.patch_stdout_stderr_write,\n    cillow.prebuilt_patches.patch_matplotlib_pyplot_show,\n    cillow.prebuilt_patches.patch_pillow_show,\n)\n\nif __name__ == \"__main__\":\n    server = cillow.Server(\n        port=5556, max_interpreters=2, interpreters_per_client=1\n    )\n    server.run()\n</code></pre> <p>Logs</p> <pre><code>[Server] Max interpreter processes: 2\n[Server] Interpreter processes per client: 1\n[Server] Number of worker threads: 4\n[Server] Max request queue size: 4\n[Server] Starting worker threads...\n[Server] Listening on tcp://127.0.0.1:5556\n[Server] Press Ctrl+C to exit.\n</code></pre> <ul> <li><code>max_interpreters</code> limits the total number of interpreter processes that can be created.</li> <li><code>interpreters_per_client</code> limits the number of interpreter processes that can be created per client.</li> </ul> <p>Refer to the Server component for more information on all parameters, their default values, and how they are calculated.</p>"},{"location":"quickstart/using_cillow/#interacting-with-the-server","title":"Interacting with the Server","text":"<pre><code>import cillow\n\nclient = cillow.Client.new(host=\"127.0.0.1\", port=5556)\n\nclient.run_code(\"\"\"\nfrom PIL import Image, ImageDraw\n\nimg = Image.new('RGB', (400, 300), 'white')\n\ndraw = ImageDraw.Draw(img)\ndraw.rectangle([50, 50, 350, 250], outline='black', width=3)\ndraw.ellipse([100, 100, 300, 200], outline='purple', width=3)\ndraw.line([50, 250, 350, 250], fill='blue', width=3)\n\nimg.show()\n\"\"\")\n</code></pre> <p>Output</p> <p> <pre><code>Execution(result=Result(value=None), streams=[], byte_streams=[ByteStream(type='image', data=b'\\x89PNG\\r\\n...', id=None)], exception=None)\n</code></pre></p> <p>Images and plot figures are sent as byte streams, so the client can access them in real-time instead of waiting for the final result. Utilize the <code>on_stream</code> callback to access the streams.</p> <p>By default, the environment is selected as <code>$system</code>, representing the global Python environment. If you wish to connect to a different environment, you can pass the environment argument.</p> <pre><code>client = cillow.Client.new(\n    host=\"127.0.0.1\", port=5556, environment=\"/path/to/python/env\"\n)\n</code></pre>"},{"location":"quickstart/using_cillow/#switching-python-environment","title":"Switching Python Environment","text":"<p>Every new environment starts up in a new interpreter process and has its own namespace.</p> <pre><code>client.switch_interpreter(\"/path/to/python/venv\")\n</code></pre>"},{"location":"quickstart/using_cillow/#deleting-python-environment","title":"Deleting Python Environment","text":"<pre><code>client.delete_interpreter(\"/path/to/python/env\")\n</code></pre> <p>After deletion, it will switch to the default environment used when creating the client.</p>"},{"location":"quickstart/using_cillow/#installing-requirements","title":"Installing Requirements","text":"<p>By default, the <code>run_code()</code> method automatically installs the required packages if they are detected in the code. To install requirements explicitly, use:</p> <pre><code>client.install_requirements(\"package1\", \"package2\")\n</code></pre> <p>To disable automatic installation feature in <code>run_code</code> method, set <code>CILLOW_DISABLE_AUTO_INSTALL</code> environment variable to <code>1</code>.</p> <p>If <code>uv</code> is installed, it will be used to install the requirements; otherwise, it will fallback to <code>pip</code>.</p>"},{"location":"quickstart/using_cillow/#running-commands","title":"Running Commands","text":"<pre><code>client.run_command(\"echo\", \"Hello World\")\n</code></pre>"},{"location":"quickstart/using_cillow/#setting-environment-variables","title":"Setting Environment Variables","text":"<pre><code>client.set_environment_variables({\"VAR1\": \"value1\", \"VAR2\": \"value2\"})\n</code></pre>"},{"location":"sdk_reference/client/","title":"cillow.Client","text":"<p>Cillow client interface.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cillow\n&gt;&gt;&gt;\n&gt;&gt;&gt; client = cillow.Client.new()  # Connect as a new client\n&gt;&gt;&gt; # OR\n&gt;&gt;&gt; client = cillow.Client(id=\"&lt;uid&gt;\")  # Connect as an existing client\n&gt;&gt;&gt;\n&gt;&gt;&gt; client.current_environment  # Get environment of selected interpreter\n'$system'\n&gt;&gt;&gt; client.all_environments  # Get environments of all running interpreter processes\n['$system']\n&gt;&gt;&gt; client.run_code(\"\"\"\n... from PIL import Image, ImageDraw\n...\n... img = Image.new('RGB', (400, 300), 'white')\n...\n... draw = ImageDraw.Draw(img)\n... draw.rectangle([50, 50, 150, 150], fill='blue')\n... draw.ellipse([200, 50, 300, 150], fill='red')\n... draw.line([50, 200, 350, 200], fill='green', width=5)\n...\n... img.show()\n... \"\"\")\n&gt;&gt;&gt; # Switch to interpreter process with given environment\n&gt;&gt;&gt; client.switch_interpreter(\"/path/to/python/env\")\n&gt;&gt;&gt; # Stop interpreter process running in given environment\n&gt;&gt;&gt; client.delete_interpreter(\"/path/to/python/env\")\n&gt;&gt;&gt; # Install requirements in the current selected environment\n&gt;&gt;&gt; client.install_requirements(\"pkg-name1\", \"pkg-name2\")\n&gt;&gt;&gt; # Run commands\n&gt;&gt;&gt; client.run_command(\"echo\", \"Hello World\")\n&gt;&gt;&gt; # Set environment variables\n&gt;&gt;&gt; client.set_environment_variables({\"VAR1\": \"value1\", \"VAR2\": \"value2\"})\n</code></pre> Source code in <code>cillow/client.py</code> <pre><code>class Client:\n    \"\"\"\n    Cillow client interface.\n\n    Examples:\n        &gt;&gt;&gt; import cillow\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; client = cillow.Client.new()  # Connect as a new client\n        &gt;&gt;&gt; # OR\n        &gt;&gt;&gt; client = cillow.Client(id=\"&lt;uid&gt;\")  # Connect as an existing client\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; client.current_environment  # Get environment of selected interpreter\n        '$system'\n        &gt;&gt;&gt; client.all_environments  # Get environments of all running interpreter processes\n        ['$system']\n        &gt;&gt;&gt; client.run_code(\\\"\\\"\\\"\n        ... from PIL import Image, ImageDraw\n        ...\n        ... img = Image.new('RGB', (400, 300), 'white')\n        ...\n        ... draw = ImageDraw.Draw(img)\n        ... draw.rectangle([50, 50, 150, 150], fill='blue')\n        ... draw.ellipse([200, 50, 300, 150], fill='red')\n        ... draw.line([50, 200, 350, 200], fill='green', width=5)\n        ...\n        ... img.show()\n        ... \\\"\\\"\\\")\n        &gt;&gt;&gt; # Switch to interpreter process with given environment\n        &gt;&gt;&gt; client.switch_interpreter(\"/path/to/python/env\")\n        &gt;&gt;&gt; # Stop interpreter process running in given environment\n        &gt;&gt;&gt; client.delete_interpreter(\"/path/to/python/env\")\n        &gt;&gt;&gt; # Install requirements in the current selected environment\n        &gt;&gt;&gt; client.install_requirements(\"pkg-name1\", \"pkg-name2\")\n        &gt;&gt;&gt; # Run commands\n        &gt;&gt;&gt; client.run_command(\"echo\", \"Hello World\")\n        &gt;&gt;&gt; # Set environment variables\n        &gt;&gt;&gt; client.set_environment_variables({\"VAR1\": \"value1\", \"VAR2\": \"value2\"})\n    \"\"\"\n\n    def __init__(\n        self,\n        id: str,  # noqa: A002\n        host: str | None = None,\n        port: int | None = None,\n        environment: PythonEnvironment | str = \"$system\",\n    ) -&gt; None:\n        \"\"\"\n        Connect to the server as an existing client.\n\n        Args:\n            id: The client id\n            host: The host to connect to (defaults to localhost)\n            port: The port to connect to (defaults to 5556)\n            environment: The default python environment to use (defaults to \"$system\")\n        \"\"\"\n        self._socket = zmq.Context().socket(zmq.DEALER)\n        self._socket.identity = id.encode()\n\n        self._url = f\"tcp://{host or 'localhost'}:{port or 5556}\"\n        self._socket.connect(self._url)\n\n        self.__id = id\n        self.__timeout: int | None = None\n        self.__current_environment: PythonEnvironment | None = None\n        self.__default_environment: PythonEnvironment | None = None\n\n        self.switch_interpreter(environment)\n\n    # fmt: off\n    @classmethod\n    def new(\n        cls,\n        host: str | None = None,\n        port: int | None = None,\n        environment: PythonEnvironment | str = \"$system\"\n    ) -&gt; Client:\n        # fmt: on\n        \"\"\"\n        Connect to the server as a new client.\n\n        Args:\n            host: The host to connect to (defaults to localhost)\n            port: The port to connect to (defaults to 5556)\n            environment: The default python environment to use (defaults to \"$system\")\n        \"\"\"\n        return cls(id=str(uuid4()), host=host, port=port, environment=environment)\n\n    def __enter__(self) -&gt; Client:\n        return self\n\n    @property\n    def id(self) -&gt; str:\n        \"\"\"Client's identifier.\"\"\"\n        return self.__id\n\n    @property\n    def request_timeout(self) -&gt; int | None:\n        \"\"\"Timeout for request in milliseconds.\"\"\"\n        return self.__timeout\n\n    @request_timeout.setter\n    def request_timeout(self, value: int) -&gt; None:\n        self.__timeout = value\n\n    @property\n    def default_environment(self) -&gt; PythonEnvironment:\n        \"\"\"Default Python environment.\"\"\"\n        if self.__default_environment is None:\n            self.__default_environment = self._get_return_value(GetPythonEnvironment(type=\"default\"))\n        return self.__default_environment\n\n    @property\n    def current_environment(self) -&gt; PythonEnvironment:\n        \"\"\"Current interpreter's python environment.\"\"\"\n        if self.__current_environment is None:\n            self.__current_environment = self._get_return_value(GetPythonEnvironment(type=\"current\"))\n        return self.__current_environment\n\n    @property\n    def all_environments(self) -&gt; list[PythonEnvironment]:\n        \"\"\"All running interpreter's python environments.\"\"\"\n        return self._get_return_value(GetPythonEnvironment(type=\"all\"))  # type: ignore[no-any-return]\n\n    def _send_request(self, request_dataclass: Any) -&gt; Generator[tuple[bytes, bytes], None, bytes]:\n        \"\"\"\n        Send a request to the server and get response generator. This is a blocking operation.\n\n        Args:\n            request_dataclass: Dataclass to send as request\n\n        Yields:\n            A tuple of message type and body\n        \"\"\"\n        self._socket.send_multipart([b\"\", pickle.dumps(request_dataclass)], flags=zmq.NOBLOCK)\n        poller = zmq.Poller()\n        poller.register(self._socket, zmq.POLLIN)\n\n        if not poller.poll(self.__timeout):\n            raise TimeoutError(\"Request timed out\")\n\n        try:\n            while True:\n                frames = self._socket.recv_multipart()\n                msg_type, body = frames[1], frames[2]\n                if msg_type == b\"request_done\":\n                    return body\n                if msg_type == b\"request_exception\":\n                    raise Exception(body.decode())\n                yield msg_type, body\n        finally:\n            poller.unregister(self._socket)\n\n    def _get_return_value(self, request_dataclass: Any) -&gt; Any:\n        gen = self._send_request(request_dataclass)\n        while True:\n            try:\n                next(gen)\n            except StopIteration as e:\n                return pickle.loads(e.value)\n\n    def switch_interpreter(self, environment: PythonEnvironment | str) -&gt; None:\n        \"\"\"\n        Switch to specified python environment's interpreter process.\n\n        Creates a new interpreter process if it is not already running.\n\n        Args:\n            environment: The Python environment to use\n        \"\"\"\n        self.__current_environment = self._get_return_value(ModifyInterpreter(environment, mode=\"switch\"))\n\n    def delete_interpreter(self, environment: PythonEnvironment | str) -&gt; None:\n        \"\"\"\n        Stop the specified python environment's interpreter process.\n\n        Switches to default python environment's  interpreter process.\n\n        Args:\n            environment: The Python environment to use\n        \"\"\"\n        self.__current_environment = self._get_return_value(ModifyInterpreter(environment, mode=\"delete\"))\n\n    def set_environment_variables(self, environment_variables: dict[str, str]) -&gt; None:\n        \"\"\"\n        Set environment variables for the current interpreter.\n\n        Args:\n            environment_variables: The environment variables to set\n        \"\"\"\n        for _ in self._send_request(SetEnvironmentVariables(environment_variables)):\n            ...\n\n    def run_command(self, *cmd: str, on_stream: Callable[[Stream], None] | None = None) -&gt; None:\n        \"\"\"\n        Run the given command.\n\n        \u26a0\ufe0f WARNING: This class allows execution of system commands and should be used with EXTREME CAUTION.\n\n        - Never run commands with user-supplied or untrusted input\n        - Always validate and sanitize any command arguments\n        - Be aware of potential security risks, especially with privilege escalation\n\n        Args:\n            cmd: The command to run\n            on_stream: The callback to capture streaming output.\n        \"\"\"\n        on_stream = on_stream or default_stream_processor\n        for msg_type, body in self._send_request(RunCommand(cmd=cmd)):\n            if msg_type != b\"interpreter\":\n                continue\n\n            on_stream(pickle.loads(body))\n\n    # fmt: off\n    def install_requirements(\n        self, *requirements: str, on_stream: Callable[[Stream], None] | None = None\n    ) -&gt; None:\n        # fmt: on\n        \"\"\"\n        Install the given requirements in the current Python environment.\n\n        Args:\n            requirements: The requirements to install\n        \"\"\"\n        on_stream = on_stream or default_stream_processor\n        for msg_type, body in self._send_request(InstallRequirements(requirements)):\n            if msg_type != b\"interpreter\":\n                continue\n\n            on_stream(pickle.loads(body))\n\n    # fmt: off\n    def run_code(\n        self,\n        code: str,\n        on_stream: Callable[[Stream | ByteStream], None] | None = None\n    ) -&gt; Execution:\n        # fmt: on\n        \"\"\"\n        Run the code in the current selected interpreter.\n\n        Args:\n            code: The code to run\n            on_stream: The callback to capture streaming output.\n\n        Returns:\n            The execution result containing the result, streams, byte streams and exception.\n        \"\"\"\n        on_stream = on_stream or default_stream_processor\n        result, streams, byte_streams, exception = Result(value=None), [], [], None\n        for msg_type, body in self._send_request(RunCode(code=code)):\n            if msg_type != b\"interpreter\":\n                continue\n\n            response = pickle.loads(body)\n            if isinstance(response, Result):\n                result = response\n                continue\n            elif isinstance(response, ExceptionInfo):\n                exception = response\n                continue\n\n            if isinstance(response, Stream):\n                streams.append(response)\n            elif isinstance(response, ByteStream):\n                byte_streams.append(response)\n\n            on_stream(response)\n\n        return Execution(\n            result=result, streams=streams, byte_streams=byte_streams, exception=exception\n        )\n\n    def disconnect(self) -&gt; None:\n        \"\"\"\n        Close the connection to the server and remove the client.\n\n        Don't use this if you want to reconnect to the server later.\n        \"\"\"\n        for _ in self._send_request(Disconnect()):\n            ...\n\n        self._socket.close()\n        self._socket.context.term()\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n        self.disconnect()\n</code></pre>"},{"location":"sdk_reference/client/#cillow.client.Client.all_environments","title":"<code>all_environments</code>  <code>property</code>","text":"<p>All running interpreter's python environments.</p>"},{"location":"sdk_reference/client/#cillow.client.Client.current_environment","title":"<code>current_environment</code>  <code>property</code>","text":"<p>Current interpreter's python environment.</p>"},{"location":"sdk_reference/client/#cillow.client.Client.default_environment","title":"<code>default_environment</code>  <code>property</code>","text":"<p>Default Python environment.</p>"},{"location":"sdk_reference/client/#cillow.client.Client.id","title":"<code>id</code>  <code>property</code>","text":"<p>Client's identifier.</p>"},{"location":"sdk_reference/client/#cillow.client.Client.request_timeout","title":"<code>request_timeout</code>  <code>property</code> <code>writable</code>","text":"<p>Timeout for request in milliseconds.</p>"},{"location":"sdk_reference/client/#cillow.client.Client.delete_interpreter","title":"<code>delete_interpreter</code>","text":"<p>Stop the specified python environment's interpreter process.</p> <p>Switches to default python environment's  interpreter process.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>PythonEnvironment | str</code> <p>The Python environment to use</p> required Source code in <code>cillow/client.py</code> <pre><code>def delete_interpreter(self, environment: PythonEnvironment | str) -&gt; None:\n    \"\"\"\n    Stop the specified python environment's interpreter process.\n\n    Switches to default python environment's  interpreter process.\n\n    Args:\n        environment: The Python environment to use\n    \"\"\"\n    self.__current_environment = self._get_return_value(ModifyInterpreter(environment, mode=\"delete\"))\n</code></pre>"},{"location":"sdk_reference/client/#cillow.client.Client.disconnect","title":"<code>disconnect</code>","text":"<p>Close the connection to the server and remove the client.</p> <p>Don't use this if you want to reconnect to the server later.</p> Source code in <code>cillow/client.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"\n    Close the connection to the server and remove the client.\n\n    Don't use this if you want to reconnect to the server later.\n    \"\"\"\n    for _ in self._send_request(Disconnect()):\n        ...\n\n    self._socket.close()\n    self._socket.context.term()\n</code></pre>"},{"location":"sdk_reference/client/#cillow.client.Client.install_requirements","title":"<code>install_requirements</code>","text":"<p>Install the given requirements in the current Python environment.</p> <p>Parameters:</p> Name Type Description Default <code>requirements</code> <code>str</code> <p>The requirements to install</p> <code>()</code> Source code in <code>cillow/client.py</code> <pre><code>def install_requirements(\n    self, *requirements: str, on_stream: Callable[[Stream], None] | None = None\n) -&gt; None:\n    # fmt: on\n    \"\"\"\n    Install the given requirements in the current Python environment.\n\n    Args:\n        requirements: The requirements to install\n    \"\"\"\n    on_stream = on_stream or default_stream_processor\n    for msg_type, body in self._send_request(InstallRequirements(requirements)):\n        if msg_type != b\"interpreter\":\n            continue\n\n        on_stream(pickle.loads(body))\n</code></pre>"},{"location":"sdk_reference/client/#cillow.client.Client.new","title":"<code>new</code>  <code>classmethod</code>","text":"<p>Connect to the server as a new client.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str | None</code> <p>The host to connect to (defaults to localhost)</p> <code>None</code> <code>port</code> <code>int | None</code> <p>The port to connect to (defaults to 5556)</p> <code>None</code> <code>environment</code> <code>PythonEnvironment | str</code> <p>The default python environment to use (defaults to \"$system\")</p> <code>'$system'</code> Source code in <code>cillow/client.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    host: str | None = None,\n    port: int | None = None,\n    environment: PythonEnvironment | str = \"$system\"\n) -&gt; Client:\n    # fmt: on\n    \"\"\"\n    Connect to the server as a new client.\n\n    Args:\n        host: The host to connect to (defaults to localhost)\n        port: The port to connect to (defaults to 5556)\n        environment: The default python environment to use (defaults to \"$system\")\n    \"\"\"\n    return cls(id=str(uuid4()), host=host, port=port, environment=environment)\n</code></pre>"},{"location":"sdk_reference/client/#cillow.client.Client.run_code","title":"<code>run_code</code>","text":"<p>Run the code in the current selected interpreter.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The code to run</p> required <code>on_stream</code> <code>Callable[[Stream | ByteStream], None] | None</code> <p>The callback to capture streaming output.</p> <code>None</code> <p>Returns:</p> Type Description <code>Execution</code> <p>The execution result containing the result, streams, byte streams and exception.</p> Source code in <code>cillow/client.py</code> <pre><code>def run_code(\n    self,\n    code: str,\n    on_stream: Callable[[Stream | ByteStream], None] | None = None\n) -&gt; Execution:\n    # fmt: on\n    \"\"\"\n    Run the code in the current selected interpreter.\n\n    Args:\n        code: The code to run\n        on_stream: The callback to capture streaming output.\n\n    Returns:\n        The execution result containing the result, streams, byte streams and exception.\n    \"\"\"\n    on_stream = on_stream or default_stream_processor\n    result, streams, byte_streams, exception = Result(value=None), [], [], None\n    for msg_type, body in self._send_request(RunCode(code=code)):\n        if msg_type != b\"interpreter\":\n            continue\n\n        response = pickle.loads(body)\n        if isinstance(response, Result):\n            result = response\n            continue\n        elif isinstance(response, ExceptionInfo):\n            exception = response\n            continue\n\n        if isinstance(response, Stream):\n            streams.append(response)\n        elif isinstance(response, ByteStream):\n            byte_streams.append(response)\n\n        on_stream(response)\n\n    return Execution(\n        result=result, streams=streams, byte_streams=byte_streams, exception=exception\n    )\n</code></pre>"},{"location":"sdk_reference/client/#cillow.client.Client.run_command","title":"<code>run_command</code>","text":"<p>Run the given command.</p> <p>\u26a0\ufe0f WARNING: This class allows execution of system commands and should be used with EXTREME CAUTION.</p> <ul> <li>Never run commands with user-supplied or untrusted input</li> <li>Always validate and sanitize any command arguments</li> <li>Be aware of potential security risks, especially with privilege escalation</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>The command to run</p> <code>()</code> <code>on_stream</code> <code>Callable[[Stream], None] | None</code> <p>The callback to capture streaming output.</p> <code>None</code> Source code in <code>cillow/client.py</code> <pre><code>def run_command(self, *cmd: str, on_stream: Callable[[Stream], None] | None = None) -&gt; None:\n    \"\"\"\n    Run the given command.\n\n    \u26a0\ufe0f WARNING: This class allows execution of system commands and should be used with EXTREME CAUTION.\n\n    - Never run commands with user-supplied or untrusted input\n    - Always validate and sanitize any command arguments\n    - Be aware of potential security risks, especially with privilege escalation\n\n    Args:\n        cmd: The command to run\n        on_stream: The callback to capture streaming output.\n    \"\"\"\n    on_stream = on_stream or default_stream_processor\n    for msg_type, body in self._send_request(RunCommand(cmd=cmd)):\n        if msg_type != b\"interpreter\":\n            continue\n\n        on_stream(pickle.loads(body))\n</code></pre>"},{"location":"sdk_reference/client/#cillow.client.Client.set_environment_variables","title":"<code>set_environment_variables</code>","text":"<p>Set environment variables for the current interpreter.</p> <p>Parameters:</p> Name Type Description Default <code>environment_variables</code> <code>dict[str, str]</code> <p>The environment variables to set</p> required Source code in <code>cillow/client.py</code> <pre><code>def set_environment_variables(self, environment_variables: dict[str, str]) -&gt; None:\n    \"\"\"\n    Set environment variables for the current interpreter.\n\n    Args:\n        environment_variables: The environment variables to set\n    \"\"\"\n    for _ in self._send_request(SetEnvironmentVariables(environment_variables)):\n        ...\n</code></pre>"},{"location":"sdk_reference/client/#cillow.client.Client.switch_interpreter","title":"<code>switch_interpreter</code>","text":"<p>Switch to specified python environment's interpreter process.</p> <p>Creates a new interpreter process if it is not already running.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>PythonEnvironment | str</code> <p>The Python environment to use</p> required Source code in <code>cillow/client.py</code> <pre><code>def switch_interpreter(self, environment: PythonEnvironment | str) -&gt; None:\n    \"\"\"\n    Switch to specified python environment's interpreter process.\n\n    Creates a new interpreter process if it is not already running.\n\n    Args:\n        environment: The Python environment to use\n    \"\"\"\n    self.__current_environment = self._get_return_value(ModifyInterpreter(environment, mode=\"switch\"))\n</code></pre>"},{"location":"sdk_reference/interpreter/","title":"cillow.Interpreter","text":"<p>Create an interpreter from a given python environment.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cillow\n&gt;&gt;&gt;\n&gt;&gt;&gt; interpreter = cillow.Interpreter()\n&gt;&gt;&gt;\n&gt;&gt;&gt; interpreter.run_code(\"x = 1; x + 1\")\nResult(value=2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; interpreter.install_requirements([\"package-name\"])\n</code></pre> <p>Don't trust LLMS? Concerned about arbitrary code execution? Take full control by limiting functionalities using patches.</p> <p>To add patches, use the <code>add_patches()</code> function. To clear patches, use <code>clear_patches()</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cillow\n&gt;&gt;&gt;\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; from contextlib import contextmanager\n&gt;&gt;&gt;\n&gt;&gt;&gt; os_system_switchable = cillow.Switchable(os.system)\n&gt;&gt;&gt;\n&gt;&gt;&gt; @contextmanager\n... def patch_os_system():\n...     def disabled_os_system(command: str):\n...         return \"os.system has been disabled.\"\n...\n...     with os_system_switchable.switch_to(disabled_os_system):\n...         yield\n...\n&gt;&gt;&gt; cillow.add_patches(patch_os_system)  # Disable os.system\n&gt;&gt;&gt;\n&gt;&gt;&gt; interpreter = cillow.Interpreter()\n&gt;&gt;&gt; interpreter.run_code(\"import os;os.system('echo Hi')\")\nResult(value='os.system has been disabled.')\n</code></pre> Source code in <code>cillow/interpreter.py</code> <pre><code>class Interpreter:\n    \"\"\"\n    Create an interpreter from a given python environment.\n\n    Examples:\n        &gt;&gt;&gt; import cillow\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; interpreter = cillow.Interpreter()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; interpreter.run_code(\"x = 1; x + 1\")\n        Result(value=2)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; interpreter.install_requirements([\"package-name\"])\n\n    Don't trust LLMS? Concerned about arbitrary code execution?\n    Take full control by limiting functionalities using patches.\n\n    To add patches, use the `add_patches()` function. To clear patches, use `clear_patches()`.\n\n    Examples:\n        &gt;&gt;&gt; import cillow\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; import os\n        &gt;&gt;&gt; from contextlib import contextmanager\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; os_system_switchable = cillow.Switchable(os.system)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; @contextmanager\n        ... def patch_os_system():\n        ...     def disabled_os_system(command: str):\n        ...         return \"os.system has been disabled.\"\n        ...\n        ...     with os_system_switchable.switch_to(disabled_os_system):\n        ...         yield\n        ...\n        &gt;&gt;&gt; cillow.add_patches(patch_os_system)  # Disable os.system\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; interpreter = cillow.Interpreter()\n        &gt;&gt;&gt; interpreter.run_code(\"import os;os.system('echo Hi')\")\n        Result(value='os.system has been disabled.')\n    \"\"\"\n\n    def __init__(self, environment: PythonEnvironment = \"$system\") -&gt; None:\n        self.namespace: dict[str, Any] = {}\n        self._import_hook = None\n        if environment != \"$system\":\n            self._import_hook = EnvironmentImportHook(environment)\n            sys.meta_path.insert(0, self._import_hook)\n            sys.path.insert(0, str(self._import_hook.site_packages))\n\n    @property\n    def environment(self) -&gt; PythonEnvironment:\n        \"\"\"The current Python environment\"\"\"\n        return getattr(self._import_hook, \"environment\", \"$system\")\n\n    # fmt: off\n    def run_command(\n        self, *cmd: str, on_stream: Callable[[Stream], Any] | None = None\n    ) -&gt; None:\n        # fmt: on\n        \"\"\"\n        Run the given command.\n\n        \u26a0\ufe0f WARNING: This class allows execution of system commands and should be used with EXTREME CAUTION.\n\n        - Never run commands with user-supplied or untrusted input\n        - Always validate and sanitize any command arguments\n        - Be aware of potential security risks, especially with privilege escalation\n\n        Args:\n            cmd: The command to run\n            on_stream: The callback to capture streaming output.\n        \"\"\"\n        on_stream = on_stream or default_stream_processor\n        for line in shell.stream(*cmd):\n            on_stream(Stream(type=\"cmd_exec\", data=line))\n\n    # fmt: off\n    def install_requirements(\n        self, *requirements: str, on_stream: Callable[[Stream], None] | None = None\n    ) -&gt; None:\n        # fmt: on\n        \"\"\"\n        Install the given requirements.\n\n        Args:\n            requirements: The requirements to install\n            on_stream: The callback to capture streaming output. (defaults to print)\n        \"\"\"\n        install_args = []\n        if self._import_hook is not None:\n            install_args = [\"--python\", str(self._import_hook.environment)]\n\n        with NamedTemporaryFile(mode=\"w\") as handler:\n            # Writing requirements to file, instead of directly\n            # passing them as arguments, to avoid arbitrary command execution\n            handler.write(\"\\n\".join(requirements))\n            handler.flush()\n            install_args.extend([\"-r\", handler.name])\n\n            self.run_command(*PIP_INSTALL_CMD, *install_args, on_stream=on_stream)\n\n    def run_code(\n        self, code: str, on_stream: Callable[[Stream | ByteStream], None] | None = None\n    ) -&gt; Result | ExceptionInfo:\n        \"\"\"\n        Run the given code.\n\n        Args:\n            code: The code to run\n            on_stream: The callback to capture streaming output.\n\n        Returns:\n            Result or ExceptionInfo dataclass instance\n        \"\"\"\n        try:\n            code_meta = CodeMeta.from_code(code, filename=\"interpreter-process\")\n        except Exception as exc:\n            return ExceptionInfo(type=exc.__class__.__name__, message=str(exc))\n\n        on_stream = on_stream or default_stream_processor\n        if not is_auto_install_disabled() and (module_names := code_meta.module_names):\n            to_install = (module_names - sys.stdlib_module_names) - get_installed_modules()\n            if to_install:\n                packages = [MODULE_TO_PACKAGE_MAP.get(name, name) for name in to_install]\n                self.install_requirements(*packages, on_stream=on_stream)\n\n        try:\n            with patch.load_patches(on_stream=on_stream):\n                if to_exec := code_meta.to_exec:\n                    exec(to_exec, self.namespace, self.namespace)  # noqa: S102\n\n                result_value = None\n                if to_eval := code_meta.to_eval:\n                    result_value = eval(to_eval, self.namespace, self.namespace)  # noqa: S307\n\n            return Result(value=result_value)\n\n        except Exception as exc:\n            exc_info = {\n                \"type\": exc.__class__.__name__,\n                \"message\": str(exc),\n            }\n            if tb := exc.__traceback__:\n                exc_info[\"where\"] = format_traceback(tb)[-1].strip()\n\n            return ExceptionInfo(**exc_info)\n\n    def __del__(self) -&gt; None:\n        if self._import_hook:\n            sys.meta_path.pop(0)\n            sys.path.pop(0)\n</code></pre>"},{"location":"sdk_reference/interpreter/#cillow.interpreter.Interpreter.environment","title":"<code>environment</code>  <code>property</code>","text":"<p>The current Python environment</p>"},{"location":"sdk_reference/interpreter/#cillow.interpreter.Interpreter.install_requirements","title":"<code>install_requirements</code>","text":"<p>Install the given requirements.</p> <p>Parameters:</p> Name Type Description Default <code>requirements</code> <code>str</code> <p>The requirements to install</p> <code>()</code> <code>on_stream</code> <code>Callable[[Stream], None] | None</code> <p>The callback to capture streaming output. (defaults to print)</p> <code>None</code> Source code in <code>cillow/interpreter.py</code> <pre><code>def install_requirements(\n    self, *requirements: str, on_stream: Callable[[Stream], None] | None = None\n) -&gt; None:\n    # fmt: on\n    \"\"\"\n    Install the given requirements.\n\n    Args:\n        requirements: The requirements to install\n        on_stream: The callback to capture streaming output. (defaults to print)\n    \"\"\"\n    install_args = []\n    if self._import_hook is not None:\n        install_args = [\"--python\", str(self._import_hook.environment)]\n\n    with NamedTemporaryFile(mode=\"w\") as handler:\n        # Writing requirements to file, instead of directly\n        # passing them as arguments, to avoid arbitrary command execution\n        handler.write(\"\\n\".join(requirements))\n        handler.flush()\n        install_args.extend([\"-r\", handler.name])\n\n        self.run_command(*PIP_INSTALL_CMD, *install_args, on_stream=on_stream)\n</code></pre>"},{"location":"sdk_reference/interpreter/#cillow.interpreter.Interpreter.run_code","title":"<code>run_code</code>","text":"<p>Run the given code.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The code to run</p> required <code>on_stream</code> <code>Callable[[Stream | ByteStream], None] | None</code> <p>The callback to capture streaming output.</p> <code>None</code> <p>Returns:</p> Type Description <code>Result | ExceptionInfo</code> <p>Result or ExceptionInfo dataclass instance</p> Source code in <code>cillow/interpreter.py</code> <pre><code>def run_code(\n    self, code: str, on_stream: Callable[[Stream | ByteStream], None] | None = None\n) -&gt; Result | ExceptionInfo:\n    \"\"\"\n    Run the given code.\n\n    Args:\n        code: The code to run\n        on_stream: The callback to capture streaming output.\n\n    Returns:\n        Result or ExceptionInfo dataclass instance\n    \"\"\"\n    try:\n        code_meta = CodeMeta.from_code(code, filename=\"interpreter-process\")\n    except Exception as exc:\n        return ExceptionInfo(type=exc.__class__.__name__, message=str(exc))\n\n    on_stream = on_stream or default_stream_processor\n    if not is_auto_install_disabled() and (module_names := code_meta.module_names):\n        to_install = (module_names - sys.stdlib_module_names) - get_installed_modules()\n        if to_install:\n            packages = [MODULE_TO_PACKAGE_MAP.get(name, name) for name in to_install]\n            self.install_requirements(*packages, on_stream=on_stream)\n\n    try:\n        with patch.load_patches(on_stream=on_stream):\n            if to_exec := code_meta.to_exec:\n                exec(to_exec, self.namespace, self.namespace)  # noqa: S102\n\n            result_value = None\n            if to_eval := code_meta.to_eval:\n                result_value = eval(to_eval, self.namespace, self.namespace)  # noqa: S307\n\n        return Result(value=result_value)\n\n    except Exception as exc:\n        exc_info = {\n            \"type\": exc.__class__.__name__,\n            \"message\": str(exc),\n        }\n        if tb := exc.__traceback__:\n            exc_info[\"where\"] = format_traceback(tb)[-1].strip()\n\n        return ExceptionInfo(**exc_info)\n</code></pre>"},{"location":"sdk_reference/interpreter/#cillow.interpreter.Interpreter.run_command","title":"<code>run_command</code>","text":"<p>Run the given command.</p> <p>\u26a0\ufe0f WARNING: This class allows execution of system commands and should be used with EXTREME CAUTION.</p> <ul> <li>Never run commands with user-supplied or untrusted input</li> <li>Always validate and sanitize any command arguments</li> <li>Be aware of potential security risks, especially with privilege escalation</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>The command to run</p> <code>()</code> <code>on_stream</code> <code>Callable[[Stream], Any] | None</code> <p>The callback to capture streaming output.</p> <code>None</code> Source code in <code>cillow/interpreter.py</code> <pre><code>def run_command(\n    self, *cmd: str, on_stream: Callable[[Stream], Any] | None = None\n) -&gt; None:\n    # fmt: on\n    \"\"\"\n    Run the given command.\n\n    \u26a0\ufe0f WARNING: This class allows execution of system commands and should be used with EXTREME CAUTION.\n\n    - Never run commands with user-supplied or untrusted input\n    - Always validate and sanitize any command arguments\n    - Be aware of potential security risks, especially with privilege escalation\n\n    Args:\n        cmd: The command to run\n        on_stream: The callback to capture streaming output.\n    \"\"\"\n    on_stream = on_stream or default_stream_processor\n    for line in shell.stream(*cmd):\n        on_stream(Stream(type=\"cmd_exec\", data=line))\n</code></pre>"},{"location":"sdk_reference/patch/","title":"cillow.patch","text":""},{"location":"sdk_reference/patch/#add_patches","title":"<code>add_patches</code>","text":"<p>Add new patches to be used by all Interpreter instances.</p> <p>Parameters:</p> Name Type Description Default <code>patches</code> <code>PatchProtocol | StreamCapturePatchProtcol</code> <p>The context manager callables to add</p> <code>()</code> Source code in <code>cillow/patch/__init__.py</code> <pre><code>def add_patches(*patches: PatchProtocol | StreamCapturePatchProtcol) -&gt; None:\n    \"\"\"\n    Add new patches to be used by all Interpreter instances.\n\n    Args:\n        patches: The context manager callables to add\n    \"\"\"\n    for patch in patches:\n        if len(signature(patch).parameters) == 0:\n            _patches_without_callback.append(patch)  # type: ignore[arg-type]\n        else:\n            _patches_with_callback.append(patch)  # type: ignore[arg-type]\n</code></pre>"},{"location":"sdk_reference/patch/#load_patches","title":"<code>load_patches</code>","text":"<p>Load the patches inside a context.</p> <p>Parameters:</p> Name Type Description Default <code>on_stream</code> <code>Callable[[Stream | ByteStream], Any]</code> <p>The callback to capture streaming output.</p> required Source code in <code>cillow/patch/__init__.py</code> <pre><code>@contextmanager\ndef load_patches(on_stream: Callable[[Stream | ByteStream], Any]) -&gt; Generator[None, None, None]:\n    \"\"\"\n    Load the patches inside a context.\n\n    Args:\n        on_stream: The callback to capture streaming output.\n    \"\"\"\n    with ExitStack() as stack:\n        for patch_fn in _patches_without_callback:\n            stack.enter_context(patch_fn())\n        for _patch_fn in _patches_with_callback:\n            stack.enter_context(_patch_fn(on_stream))\n        yield\n</code></pre>"},{"location":"sdk_reference/patch/#clear_patches","title":"<code>clear_patches</code>","text":"<p>Clear all the added patches.</p> Source code in <code>cillow/patch/__init__.py</code> <pre><code>def clear_patches() -&gt; None:\n    \"\"\"Clear all the added patches.\"\"\"\n    _patches_with_callback.clear()\n    _patches_without_callback.clear()\n</code></pre>"},{"location":"sdk_reference/prebuilt_patches/","title":"cillow.prebuilt_patches","text":""},{"location":"sdk_reference/prebuilt_patches/#patch_stdout_stderr_write","title":"<code>patch_stdout_stderr_write</code>","text":"<p>Patch the <code>write</code> method of <code>sys.stdout</code> and <code>sys.stderr</code>.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Stream], Any]</code> <p>The callback to process the string content.</p> required Source code in <code>cillow/patch/prebuilt.py</code> <pre><code>@contextmanager\ndef patch_stdout_stderr_write(callback: Callable[[Stream], Any]) -&gt; Generator[None, None, None]:\n    \"\"\"\n    Patch the `write` method of `sys.stdout` and `sys.stderr`.\n\n    Args:\n        callback: The callback to process the string content.\n    \"\"\"\n    with (\n        stdout_write_switchable.switch_to(lambda s: callback(Stream(type=\"stdout\", data=s))),\n        stderr_write_switchable.switch_to(lambda s: callback(Stream(type=\"stderr\", data=s))),\n    ):\n        yield\n</code></pre>"},{"location":"sdk_reference/prebuilt_patches/#patch_matplotlib_pyplot_show","title":"<code>patch_matplotlib_pyplot_show</code>","text":"<p>Patch the <code>matplotlib.pyplot.show</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ByteStream], Any]</code> <p>The callback to process the figure image bytes.</p> required Source code in <code>cillow/patch/prebuilt.py</code> <pre><code>@contextmanager\ndef patch_matplotlib_pyplot_show(callback: Callable[[ByteStream], Any]) -&gt; Generator[None, None, None]:\n    \"\"\"\n    Patch the `matplotlib.pyplot.show` function.\n\n    Args:\n        callback: The callback to process the figure image bytes.\n    \"\"\"\n\n    def override_show(*args: Any, **kwargs: Any) -&gt; Any:\n        buffer = BytesIO()\n        try:\n            pyplot.savefig(buffer, format=\"png\")\n            buffer.seek(0)\n\n            return callback(ByteStream(type=\"image\", data=buffer.getvalue()))\n        finally:\n            buffer.close()\n            pyplot.close()\n\n    with (\n        matplotlib_pyplot_show_switchable.switch_to(override_show),\n        matplotlib_use_backend_switchable.switch_to(lambda b, f=True: None),  # type: ignore[misc,arg-type]\n    ):\n        yield\n</code></pre>"},{"location":"sdk_reference/prebuilt_patches/#patch_pillow_show","title":"<code>patch_pillow_show</code>","text":"<p>Patch the <code>PIL.Image.show</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ByteStream], Any]</code> <p>The callback to process the image bytes.</p> required Source code in <code>cillow/patch/prebuilt.py</code> <pre><code>@contextmanager\ndef patch_pillow_show(callback: Callable[[ByteStream], Any]) -&gt; Generator[None, None, None]:\n    \"\"\"\n    Patch the `PIL.Image.show` method.\n\n    Args:\n        callback: The callback to process the image bytes.\n    \"\"\"\n\n    def override_show(image: Image.Image, **options: Any) -&gt; Any:\n        data = image._repr_image(\"PNG\", compress_level=1)\n        if data:\n            return callback(ByteStream(type=\"image\", data=data))\n\n    with pillow_show_switchable.switch_to(override_show):\n        yield\n</code></pre>"},{"location":"sdk_reference/server/","title":"cillow.Server","text":"<p>Cillow server component.</p> <p>This class is responsible for managing request workers and client manager.</p> <ul> <li><code>max_interpreters</code> limits the total number of processes that can be created.</li> <li><code>interpreters_per_client</code> limits the number of processes that can be created per client.</li> <li><code>num_worker_threads</code> limits the number of request worker threads.</li> <li><code>max_queue_size</code> limits the maximum size of the request queue.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cillow\n&gt;&gt;&gt;\n&gt;&gt;&gt; if __name__ == \"__main__\":\n...     server = cillow.Server(port=5556, max_interpreters=2, interpreters_per_client=1)\n...     server.run()\n</code></pre> <p>Don't trust LLMS? Concerned about arbitrary code execution? Take full control by limiting functionalities using patches.</p> <p>To add patches, use the <code>add_patches()</code> function. To clear patches, use <code>clear_patches()</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cillow\n&gt;&gt;&gt;\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; from contextlib import contextmanager\n&gt;&gt;&gt;\n&gt;&gt;&gt; os_system_switchable = cillow.Switchable(os.system)\n&gt;&gt;&gt;\n&gt;&gt;&gt; @contextmanager\n... def patch_os_system():\n...     def disabled_os_system(command: str):\n...         return \"os.system has been disabled.\"\n...\n...     with os_system_switchable.switch_to(disabled_os_system):\n...         yield\n...\n&gt;&gt;&gt; cillow.add_patches(\n...     patch_os_system,  # Disable os.system\n...     cillow.prebuilt_patches.patch_stdout_stderr_write,  # To capture stdout and stderr\n...     cillow.prebuilt_patches.patch_matplotlib_pyplot_show,  # To capture matplotlib figures\n...     cillow.prebuilt_patches.patch_pillow_show,  # To capture PIL images\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; if __name__ == \"__main__\":\n...     server = cillow.Server(port=5556, max_interpreters=2, interpreters_per_client=1)\n...     server.run()\n</code></pre> Source code in <code>cillow/server/__init__.py</code> <pre><code>class Server(Logger):\n    \"\"\"\n    Cillow server component.\n\n    This class is responsible for managing request workers and client manager.\n\n    - `max_interpreters` limits the total number of processes that can be created.\n    - `interpreters_per_client` limits the number of processes that can be created per client.\n    - `num_worker_threads` limits the number of request worker threads.\n    - `max_queue_size` limits the maximum size of the request queue.\n\n    Examples:\n        &gt;&gt;&gt; import cillow\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; if __name__ == \"__main__\":\n        ...     server = cillow.Server(port=5556, max_interpreters=2, interpreters_per_client=1)\n        ...     server.run()\n\n    Don't trust LLMS? Concerned about arbitrary code execution?\n    Take full control by limiting functionalities using patches.\n\n    To add patches, use the `add_patches()` function. To clear patches, use `clear_patches()`.\n\n    Examples:\n        &gt;&gt;&gt; import cillow\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; import os\n        &gt;&gt;&gt; from contextlib import contextmanager\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; os_system_switchable = cillow.Switchable(os.system)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; @contextmanager\n        ... def patch_os_system():\n        ...     def disabled_os_system(command: str):\n        ...         return \"os.system has been disabled.\"\n        ...\n        ...     with os_system_switchable.switch_to(disabled_os_system):\n        ...         yield\n        ...\n        &gt;&gt;&gt; cillow.add_patches(\n        ...     patch_os_system,  # Disable os.system\n        ...     cillow.prebuilt_patches.patch_stdout_stderr_write,  # To capture stdout and stderr\n        ...     cillow.prebuilt_patches.patch_matplotlib_pyplot_show,  # To capture matplotlib figures\n        ...     cillow.prebuilt_patches.patch_pillow_show,  # To capture PIL images\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; if __name__ == \"__main__\":\n        ...     server = cillow.Server(port=5556, max_interpreters=2, interpreters_per_client=1)\n        ...     server.run()\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        port: int,\n        max_interpreters: int | None = None,\n        interpreters_per_client: int | None = None,\n        num_worker_threads: int | None = None,\n        max_queue_size: int | None = None,\n    ):\n        \"\"\"\n        Args:\n            port: The port to bind the server to\n            max_interpreters: Maximum total interpreter processes allowed. (defaults to `os.cpu_count()`)\n            interpreters_per_client: Maximum interpreters per client (defaults to `min(2, max_interpreters)`)\n            num_worker_threads: Number of worker threads (defaults to `min(2 * max_clients, os.cpu_count())`)\n            max_queue_size: Maximum queue size (defaults to `max_clients * interpreters_per_client * 2`)\n        \"\"\"\n        self.socket = zmq.Context().socket(zmq.ROUTER)\n        self._url = f\"tcp://0.0.0.0:{port}\"\n        self.socket.bind(self._url)\n\n        self._client_manager = ClientManager(max_interpreters, interpreters_per_client)\n\n        if num_worker_threads is None:\n            num_worker_threads = self._client_manager.optimal_number_of_request_workers\n\n        if max_queue_size is None:\n            max_queue_size = self._client_manager.optimal_max_queue_size\n\n        self.logger.info(f\"Max interpreter processes: {self._client_manager.max_interpreters}\")\n        self.logger.info(f\"Interpreter processes per client: {self._client_manager.interpreters_per_client}\")\n        self.logger.info(f\"Number of worker threads: {num_worker_threads}\")\n        self.logger.info(f\"Max request queue size: {max_queue_size}\")\n\n        self._request_queue = Queue(maxsize=max_queue_size)  # type: ignore[var-annotated]\n\n        def send_cb(client_id: bytes, msg_type: bytes, msg_body: bytes) -&gt; None:\n            self.socket.send_multipart([client_id, b\"\", msg_type, msg_body])\n\n        self._callback = send_cb\n        self._server_event = ThreadEvent()\n        self._request_workers = [\n            RequestWorker(\n                self._request_queue,\n                self._client_manager,\n                self._callback,  # type: ignore[arg-type]\n                self._server_event,\n            )\n            for _ in range(num_worker_threads)\n        ]\n\n    def run(self) -&gt; None:\n        \"\"\"Run the server and block until interrupted.\"\"\"\n\n        self.logger.info(\"Starting worker threads...\")\n        for worker in self._request_workers:\n            worker.start()\n\n        signal(Signals.SIGINT, lambda s, f: self._server_event.set())\n        signal(Signals.SIGTERM, lambda s, f: self._server_event.set())\n\n        self._server_event.clear()\n\n        try:\n            self.logger.info(f\"Listening on {self._url}\")\n            self.logger.info(\"Press Ctrl+C to exit.\")\n            while not self._server_event.is_set():\n                if not self.socket.poll(timeout=1000):\n                    continue\n\n                try:\n                    frames = self.socket.recv_multipart(flags=zmq.NOBLOCK)\n                    if len(frames) != 3:\n                        self._callback(frames[0], b\"request_exception\", b\"Invalid number of frames received\")\n\n                    client_id, _, request_bytes = frames\n                    try:\n                        self._request_queue.put_nowait((client_id, request_bytes))\n                    except QueueFullError:\n                        self._callback(\n                            client_id, b\"request_exception\", b\"Server request queue is full. Try again later.\"\n                        )\n\n                except zmq.ZMQError:\n                    pass\n\n        except Exception as e:\n            self.logger.error(f\"{e.__class__.__name__}: {e!s}\")\n\n        finally:\n            self.logger.info(\"Cleaning up resources...\")\n            self._client_manager.cleanup()\n\n            self.logger.info(\"Stopping worker threads...\")\n            for worker in self._request_workers:\n                worker.join()\n\n            self.socket.close()\n            self.socket.context.term()\n            self.logger.info(\"Shutdown complete.\")\n</code></pre>"},{"location":"sdk_reference/server/#cillow.server.Server.run","title":"<code>run</code>","text":"<p>Run the server and block until interrupted.</p> Source code in <code>cillow/server/__init__.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the server and block until interrupted.\"\"\"\n\n    self.logger.info(\"Starting worker threads...\")\n    for worker in self._request_workers:\n        worker.start()\n\n    signal(Signals.SIGINT, lambda s, f: self._server_event.set())\n    signal(Signals.SIGTERM, lambda s, f: self._server_event.set())\n\n    self._server_event.clear()\n\n    try:\n        self.logger.info(f\"Listening on {self._url}\")\n        self.logger.info(\"Press Ctrl+C to exit.\")\n        while not self._server_event.is_set():\n            if not self.socket.poll(timeout=1000):\n                continue\n\n            try:\n                frames = self.socket.recv_multipart(flags=zmq.NOBLOCK)\n                if len(frames) != 3:\n                    self._callback(frames[0], b\"request_exception\", b\"Invalid number of frames received\")\n\n                client_id, _, request_bytes = frames\n                try:\n                    self._request_queue.put_nowait((client_id, request_bytes))\n                except QueueFullError:\n                    self._callback(\n                        client_id, b\"request_exception\", b\"Server request queue is full. Try again later.\"\n                    )\n\n            except zmq.ZMQError:\n                pass\n\n    except Exception as e:\n        self.logger.error(f\"{e.__class__.__name__}: {e!s}\")\n\n    finally:\n        self.logger.info(\"Cleaning up resources...\")\n        self._client_manager.cleanup()\n\n        self.logger.info(\"Stopping worker threads...\")\n        for worker in self._request_workers:\n            worker.join()\n\n        self.socket.close()\n        self.socket.context.term()\n        self.logger.info(\"Shutdown complete.\")\n</code></pre>"},{"location":"sdk_reference/server/#client-manager","title":"Client Manager","text":"<p>Manages clients and their interpreter processes.</p> <p>This class is utilized by the server component to share the instance with all the request worker threads.</p> Source code in <code>cillow/server/client_manager.py</code> <pre><code>class ClientManager(Logger):\n    \"\"\"\n    Manages clients and their interpreter processes.\n\n    This class is utilized by the server component to share the instance with all the request worker threads.\n    \"\"\"\n\n    def __init__(self, max_interpreters: int | None = None, interpreters_per_client: int | None = None):\n        \"\"\"\n        Initialize the client manager.\n\n        Args:\n            max_interpreters: Maximum total interpreter processes allowed. Defaults to `os.cpu_count()`\n            interpreters_per_client: Maximum processes per client. Defaults to `min(2, max_interpreters)`\n        \"\"\"\n        self.cpu_count = multiprocessing.cpu_count()\n        self.max_interpreters = min(max_interpreters or self.cpu_count, self.cpu_count)\n        self.interpreters_per_client = interpreters_per_client or min(2, self.max_interpreters)\n        self.max_clients = self.max_interpreters // self.interpreters_per_client\n\n        self._lock = threading.Lock()\n        self._clients: dict[str, ClientInfo] = {}\n\n    @property\n    def optimal_number_of_request_workers(self) -&gt; int:\n        \"\"\"Optimal number of request worker threads based on current limits.\"\"\"\n        return min(2 * self.max_clients, self.cpu_count)\n\n    @property\n    def optimal_max_queue_size(self) -&gt; int:\n        \"\"\"Get optimal maximum queue size based on current limits.\"\"\"\n        return self.max_clients * self.interpreters_per_client * 2\n\n    @property\n    def total_active_processes(self) -&gt; int:\n        \"\"\"Get total number of active interpreter processes.\"\"\"\n        return sum(len(client.interpreters) for client in self._clients.values())\n\n    def register(self, client_id: str, environment: PythonEnvironment | str = \"$system\") -&gt; None:\n        \"\"\"\n        Register a client if possible.\n\n        Args:\n            client_id: The client identifier\n            environment: The environment to use. This environment will be used as default when an interpreter process is deleted.\n\n        Raises:\n            Exception: If the client limit is exceeded.\n            LookupError: If the given environment is invalid or not found.\n        \"\"\"\n        with self._lock:\n            if client_id in self._clients:\n                return\n\n            # Check if a new client can be accepted based on current limits.\n            if not len(self._clients) &lt; self.max_clients:\n                raise Exception(\"Client limit exceeded. Try again later.\")\n\n            environment = validate_environment(environment or \"$system\")\n            interpreter = _InterpreterProcess(environment)\n            self._clients[client_id] = ClientInfo(\n                default_environment=environment,\n                current=CurrentContext(environment=environment, interpreter=interpreter),\n                interpreters={environment: interpreter},\n            )\n            self.logger.info(f\"Client {client_id!r} joined the server with {str(environment)!r} environment\")\n\n    def get_info(self, client_id: str) -&gt; ClientInfo | None:\n        \"\"\"Get client info\"\"\"\n        with self._lock:\n            return self._clients.get(client_id)\n\n    def switch_interpreter(self, client_id: str, environment: PythonEnvironment | str) -&gt; PythonEnvironment:\n        \"\"\"\n        Switch client to interpreter process based on the given environment.\n\n        Args:\n            client_id: The client identifier\n            environment: The environment to switch to\n\n        Raises:\n            Exception: If unable to create new interpreter due to process limit\n            LookupError: If the given environment is invalid or not found\n            ValueError: If client is not found\n\n        Returns:\n            The valid Python environment value\n        \"\"\"\n        with self._lock:\n            if (client_info := self._clients.get(client_id)) is None:\n                raise ValueError(f\"Client {client_id!r} not found.\")\n\n            environment = validate_environment(environment)\n            if client_info.current.environment == environment:\n                return environment\n\n            if not (interpreter := client_info.interpreters.get(environment)):\n                # Check if client and total process limits are met to create new interpreter\n                if (\n                    len(client_info.interpreters) &lt; self.interpreters_per_client\n                    and self.total_active_processes &lt; self.max_interpreters\n                ):\n                    interpreter = _InterpreterProcess(environment)\n                    client_info.interpreters[environment] = interpreter\n                else:\n                    raise Exception(\"Unable to create new interpreter due to process limit.\")\n\n            self._clients[client_id].current = CurrentContext(environment=environment, interpreter=interpreter)\n            return environment\n\n    def delete_interpreter(self, client_id: str, environment: PythonEnvironment | str) -&gt; None:\n        \"\"\"\n        Delete client's interpreter processes at the given environment.\n\n        Args:\n            client_id: The client identifier\n            environment: The environment associated with the interpreter\n        \"\"\"\n        with self._lock:\n            if (client_info := self._clients.get(client_id)) is None:\n                return\n\n            try:\n                environment = validate_environment(environment)\n                client_info.interpreters.pop(environment).stop()\n            except KeyError:\n                return\n\n    def remove(self, client_id: str) -&gt; None:\n        \"\"\"\n        Remove a client and stop all its interpreter processes.\n\n        Args:\n            client_id: The client identifier\n        \"\"\"\n        with self._lock:\n            if (client_info := self._clients.get(client_id)) is None:\n                return\n\n            for interpreter in client_info.interpreters.values():\n                interpreter.stop()\n            del self._clients[client_id]\n            self.logger.info(f\"Client {client_id!r} left the server\")\n\n    def cleanup(self) -&gt; None:\n        \"\"\"Stop all the interpreter processes.\"\"\"\n        for info in self._clients.values():\n            for interpreter in info.interpreters.values():\n                interpreter.stop()\n        self._clients.clear()\n</code></pre>"},{"location":"sdk_reference/server/#cillow.server.client_manager.ClientManager.optimal_max_queue_size","title":"<code>optimal_max_queue_size</code>  <code>property</code>","text":"<p>Get optimal maximum queue size based on current limits.</p>"},{"location":"sdk_reference/server/#cillow.server.client_manager.ClientManager.optimal_number_of_request_workers","title":"<code>optimal_number_of_request_workers</code>  <code>property</code>","text":"<p>Optimal number of request worker threads based on current limits.</p>"},{"location":"sdk_reference/server/#cillow.server.client_manager.ClientManager.total_active_processes","title":"<code>total_active_processes</code>  <code>property</code>","text":"<p>Get total number of active interpreter processes.</p>"},{"location":"sdk_reference/server/#cillow.server.client_manager.ClientManager.cleanup","title":"<code>cleanup</code>","text":"<p>Stop all the interpreter processes.</p> Source code in <code>cillow/server/client_manager.py</code> <pre><code>def cleanup(self) -&gt; None:\n    \"\"\"Stop all the interpreter processes.\"\"\"\n    for info in self._clients.values():\n        for interpreter in info.interpreters.values():\n            interpreter.stop()\n    self._clients.clear()\n</code></pre>"},{"location":"sdk_reference/server/#cillow.server.client_manager.ClientManager.delete_interpreter","title":"<code>delete_interpreter</code>","text":"<p>Delete client's interpreter processes at the given environment.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client identifier</p> required <code>environment</code> <code>PythonEnvironment | str</code> <p>The environment associated with the interpreter</p> required Source code in <code>cillow/server/client_manager.py</code> <pre><code>def delete_interpreter(self, client_id: str, environment: PythonEnvironment | str) -&gt; None:\n    \"\"\"\n    Delete client's interpreter processes at the given environment.\n\n    Args:\n        client_id: The client identifier\n        environment: The environment associated with the interpreter\n    \"\"\"\n    with self._lock:\n        if (client_info := self._clients.get(client_id)) is None:\n            return\n\n        try:\n            environment = validate_environment(environment)\n            client_info.interpreters.pop(environment).stop()\n        except KeyError:\n            return\n</code></pre>"},{"location":"sdk_reference/server/#cillow.server.client_manager.ClientManager.get_info","title":"<code>get_info</code>","text":"<p>Get client info</p> Source code in <code>cillow/server/client_manager.py</code> <pre><code>def get_info(self, client_id: str) -&gt; ClientInfo | None:\n    \"\"\"Get client info\"\"\"\n    with self._lock:\n        return self._clients.get(client_id)\n</code></pre>"},{"location":"sdk_reference/server/#cillow.server.client_manager.ClientManager.register","title":"<code>register</code>","text":"<p>Register a client if possible.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client identifier</p> required <code>environment</code> <code>PythonEnvironment | str</code> <p>The environment to use. This environment will be used as default when an interpreter process is deleted.</p> <code>'$system'</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the client limit is exceeded.</p> <code>LookupError</code> <p>If the given environment is invalid or not found.</p> Source code in <code>cillow/server/client_manager.py</code> <pre><code>def register(self, client_id: str, environment: PythonEnvironment | str = \"$system\") -&gt; None:\n    \"\"\"\n    Register a client if possible.\n\n    Args:\n        client_id: The client identifier\n        environment: The environment to use. This environment will be used as default when an interpreter process is deleted.\n\n    Raises:\n        Exception: If the client limit is exceeded.\n        LookupError: If the given environment is invalid or not found.\n    \"\"\"\n    with self._lock:\n        if client_id in self._clients:\n            return\n\n        # Check if a new client can be accepted based on current limits.\n        if not len(self._clients) &lt; self.max_clients:\n            raise Exception(\"Client limit exceeded. Try again later.\")\n\n        environment = validate_environment(environment or \"$system\")\n        interpreter = _InterpreterProcess(environment)\n        self._clients[client_id] = ClientInfo(\n            default_environment=environment,\n            current=CurrentContext(environment=environment, interpreter=interpreter),\n            interpreters={environment: interpreter},\n        )\n        self.logger.info(f\"Client {client_id!r} joined the server with {str(environment)!r} environment\")\n</code></pre>"},{"location":"sdk_reference/server/#cillow.server.client_manager.ClientManager.remove","title":"<code>remove</code>","text":"<p>Remove a client and stop all its interpreter processes.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client identifier</p> required Source code in <code>cillow/server/client_manager.py</code> <pre><code>def remove(self, client_id: str) -&gt; None:\n    \"\"\"\n    Remove a client and stop all its interpreter processes.\n\n    Args:\n        client_id: The client identifier\n    \"\"\"\n    with self._lock:\n        if (client_info := self._clients.get(client_id)) is None:\n            return\n\n        for interpreter in client_info.interpreters.values():\n            interpreter.stop()\n        del self._clients[client_id]\n        self.logger.info(f\"Client {client_id!r} left the server\")\n</code></pre>"},{"location":"sdk_reference/server/#cillow.server.client_manager.ClientManager.switch_interpreter","title":"<code>switch_interpreter</code>","text":"<p>Switch client to interpreter process based on the given environment.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client identifier</p> required <code>environment</code> <code>PythonEnvironment | str</code> <p>The environment to switch to</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If unable to create new interpreter due to process limit</p> <code>LookupError</code> <p>If the given environment is invalid or not found</p> <code>ValueError</code> <p>If client is not found</p> <p>Returns:</p> Type Description <code>PythonEnvironment</code> <p>The valid Python environment value</p> Source code in <code>cillow/server/client_manager.py</code> <pre><code>def switch_interpreter(self, client_id: str, environment: PythonEnvironment | str) -&gt; PythonEnvironment:\n    \"\"\"\n    Switch client to interpreter process based on the given environment.\n\n    Args:\n        client_id: The client identifier\n        environment: The environment to switch to\n\n    Raises:\n        Exception: If unable to create new interpreter due to process limit\n        LookupError: If the given environment is invalid or not found\n        ValueError: If client is not found\n\n    Returns:\n        The valid Python environment value\n    \"\"\"\n    with self._lock:\n        if (client_info := self._clients.get(client_id)) is None:\n            raise ValueError(f\"Client {client_id!r} not found.\")\n\n        environment = validate_environment(environment)\n        if client_info.current.environment == environment:\n            return environment\n\n        if not (interpreter := client_info.interpreters.get(environment)):\n            # Check if client and total process limits are met to create new interpreter\n            if (\n                len(client_info.interpreters) &lt; self.interpreters_per_client\n                and self.total_active_processes &lt; self.max_interpreters\n            ):\n                interpreter = _InterpreterProcess(environment)\n                client_info.interpreters[environment] = interpreter\n            else:\n                raise Exception(\"Unable to create new interpreter due to process limit.\")\n\n        self._clients[client_id].current = CurrentContext(environment=environment, interpreter=interpreter)\n        return environment\n</code></pre>"},{"location":"sdk_reference/server/#request-worker","title":"Request Worker","text":"<p>Request worker thread to handle incoming requests from clients.</p> Source code in <code>cillow/server/request_worker.py</code> <pre><code>class RequestWorker(Thread, Logger):\n    \"\"\"Request worker thread to handle incoming requests from clients.\"\"\"\n\n    def __init__(\n        self,\n        queue: Queue,\n        client_manager: ClientManager,\n        callback: WriteCallback,\n        stop_event: ThreadEvent,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the worker thread.\n\n        Args:\n            queue: The queue to receive requests from\n            client_manager: The client manager instance to use for processing client requests\n            callback: The callback to write responses to\n            stop_event: The event to stop the worker thread\n        \"\"\"\n        self._queue = queue\n        self._client_manager = client_manager\n        self._stop_event = stop_event\n        self._callback = callback\n        super().__init__(daemon=True)\n\n    def _get_python_environment(self, client_id: bytes, type: Literal[\"current\", \"all\", \"default\"]) -&gt; None:  # noqa: A002\n        \"\"\"\n        Get client's python environment of certain type.\n\n        Args:\n            client_id: The client id\n            type: The type of python environment to get\n        \"\"\"\n        if (client_info := self._client_manager.get_info(client_id.decode())) is None:\n            return\n\n        if type == \"all\":\n            self._callback(client_id, b\"request_done\", pickle.dumps(list(client_info.interpreters)))\n        elif type == \"current\":\n            self._callback(client_id, b\"request_done\", pickle.dumps(client_info.current.environment))\n        elif type == \"default\":\n            self._callback(client_id, b\"request_done\", pickle.dumps(client_info.default_environment))\n\n    def _modify_interpreter(\n        self, client_id: bytes, environment: PythonEnvironment | str, mode: Literal[\"switch\", \"delete\"]\n    ) -&gt; None:\n        \"\"\"\n        Modify the client's interpreter based on the given environment and mode.\n\n        Args:\n            client_id: The client id\n            environment: The environment to use\n            mode: The mode to use\n        \"\"\"\n        client_id_str = client_id.decode()\n        # fmt: off\n        _switch = lambda env: self._callback(\n            client_id,\n            b\"request_done\",\n            pickle.dumps(self._client_manager.switch_interpreter(client_id_str, env))\n        )\n        # fmt: on\n        try:\n            if mode == \"switch\":\n                _switch(environment)\n            elif mode == \"delete\":\n                self._client_manager.delete_interpreter(client_id_str, environment)\n                _switch(self._client_manager.get_info(client_id_str).default_environment)  # type: ignore[union-attr]\n\n        except Exception as e:\n            print(str(e))\n            self._callback(client_id, b\"request_exception\", str(e).encode())\n\n    def _send_input_to_interpreter(self, client_id: bytes, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Send input to interpreter.\n\n        Args:\n            client_id: The client id\n            **kwargs: The input data\n        \"\"\"\n        if (client_info := self._client_manager.get_info(client_id.decode())) is None:\n            return\n\n        for response in client_info.current.interpreter._send_input(**kwargs):\n            self._callback(client_id, b\"interpreter\", pickle.dumps(response))\n\n        # Tell client to not wait for more responses\n        self._callback(client_id, b\"request_done\", b\"\")\n\n    def run(self) -&gt; None:\n        \"\"\"Run the worker thread.\"\"\"\n        while not self._stop_event.is_set():\n            try:\n                client_id, request_bytes = cast(tuple[bytes, bytes], self._queue.get(timeout=1))\n                request = pickle.loads(request_bytes)\n                try:\n                    client_id_str = client_id.decode()\n                    if isinstance(request, ModifyInterpreter):\n                        # Register with default environment\n                        self._client_manager.register(client_id_str, request.environment)\n                    else:\n                        self._client_manager.register(client_id_str)\n\n                except Exception as e:\n                    self._callback(client_id, b\"request_exception\", str(e).encode())\n                    continue\n\n                if isinstance(request, GetPythonEnvironment):\n                    self._get_python_environment(client_id, request.type)\n                elif isinstance(request, ModifyInterpreter):\n                    self._modify_interpreter(client_id, request.environment, request.mode)\n                elif isinstance(request, (SetEnvironmentVariables, InstallRequirements, RunCode, RunCommand)):\n                    self._send_input_to_interpreter(client_id, **request.__dict__)\n                elif isinstance(request, Disconnect):\n                    self._client_manager.remove(client_id.decode())\n                    self._callback(client_id, b\"request_done\", b\"\")\n            except QueueEmptyError:\n                continue\n            except Exception as e:\n                self.logger.error(f\"{e.__class__.__name__}: {e!s}\")\n</code></pre>"},{"location":"sdk_reference/server/#cillow.server.request_worker.RequestWorker.run","title":"<code>run</code>","text":"<p>Run the worker thread.</p> Source code in <code>cillow/server/request_worker.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the worker thread.\"\"\"\n    while not self._stop_event.is_set():\n        try:\n            client_id, request_bytes = cast(tuple[bytes, bytes], self._queue.get(timeout=1))\n            request = pickle.loads(request_bytes)\n            try:\n                client_id_str = client_id.decode()\n                if isinstance(request, ModifyInterpreter):\n                    # Register with default environment\n                    self._client_manager.register(client_id_str, request.environment)\n                else:\n                    self._client_manager.register(client_id_str)\n\n            except Exception as e:\n                self._callback(client_id, b\"request_exception\", str(e).encode())\n                continue\n\n            if isinstance(request, GetPythonEnvironment):\n                self._get_python_environment(client_id, request.type)\n            elif isinstance(request, ModifyInterpreter):\n                self._modify_interpreter(client_id, request.environment, request.mode)\n            elif isinstance(request, (SetEnvironmentVariables, InstallRequirements, RunCode, RunCommand)):\n                self._send_input_to_interpreter(client_id, **request.__dict__)\n            elif isinstance(request, Disconnect):\n                self._client_manager.remove(client_id.decode())\n                self._callback(client_id, b\"request_done\", b\"\")\n        except QueueEmptyError:\n            continue\n        except Exception as e:\n            self.logger.error(f\"{e.__class__.__name__}: {e!s}\")\n</code></pre>"},{"location":"sdk_reference/switchable/","title":"cillow.Switchable","text":"<p>Create a switch from callable that can be replaced with another callable temporarily. Supports module-level functions, classes, class methods and instance methods.</p> <p>Features:</p> <ul> <li>Supports re-entrant context managers (nested switching)</li> <li>When exiting a context manager, the callable is restored to the previous state:<ul> <li>For nested switches, this means restoring to the previous replacement</li> <li>Only when exiting the outermost context manager is the original callable restored</li> </ul> </li> <li>Works with any callable that has a parent object (module, class, or instance)</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Example 1: Redirecting sys.stdout.write to a file\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt;\n&gt;&gt;&gt; switchable = Switchable(sys.stdout.write)\n&gt;&gt;&gt; with switchable.switch_to(Path('test.txt').open('a').write):\n...     # Redirect print output to the file 'test.txt'\n...     print(\"This will go into the file!\")\n&gt;&gt;&gt; print(\"This will print to the console.\")\nThis will print to the console.\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Example 2: Nested switching with re-entrant context managers\n&gt;&gt;&gt; import logging\n&gt;&gt;&gt;\n&gt;&gt;&gt; def custom_write_1(text):\n...     logging.error(f\"[Logger 1] {text}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; def custom_write_2(text):\n...     logging.error(f\"[Logger 2] {text}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; switchable = Switchable(print)\n&gt;&gt;&gt; with switchable.switch_to(custom_write_1):\n...     print(\"Message 1\")\n...     with switchable.switch_to(custom_write_2):\n...         print(\"Message 2\")\n...     print(\"Message 3\")\n&gt;&gt;&gt; print(\"Message 4\")\nERROR:root:[Logger 1] Message 1\nERROR:root:[Logger 2] Message 2\nERROR:root:[Logger 1] Message 3\nMessage 4\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Example 3: Mocking a callable for testing\n&gt;&gt;&gt; import random\n&gt;&gt;&gt;\n&gt;&gt;&gt; def mock_random_choice(seq):\n...     return seq[0]  # Always return the first element\n&gt;&gt;&gt;\n&gt;&gt;&gt; switchable = Switchable(random.choice)\n&gt;&gt;&gt; with switchable.switch_to(mock_random_choice):\n...     print(random.choice(list(range(10))))\n&gt;&gt;&gt; print(random.choice(list(range(10))))\n0\n5\n</code></pre> Source code in <code>cillow/switchable.py</code> <pre><code>class Switchable(Generic[P_Spec, T_Retval]):\n    \"\"\"\n    Create a switch from callable that can be replaced with another callable temporarily.\n    Supports module-level functions, classes, class methods and instance methods.\n\n    Features:\n\n    - Supports re-entrant context managers (nested switching)\n    - When exiting a context manager, the callable is restored to the previous state:\n        - For nested switches, this means restoring to the previous replacement\n        - Only when exiting the outermost context manager is the original callable restored\n    - Works with any callable that has a parent object (module, class, or instance)\n\n    Examples:\n        &gt;&gt;&gt; # Example 1: Redirecting sys.stdout.write to a file\n        &gt;&gt;&gt; import sys\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; switchable = Switchable(sys.stdout.write)\n        &gt;&gt;&gt; with switchable.switch_to(Path('test.txt').open('a').write):\n        ...     # Redirect print output to the file 'test.txt'\n        ...     print(\"This will go into the file!\")\n        &gt;&gt;&gt; print(\"This will print to the console.\")\n        This will print to the console.\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Example 2: Nested switching with re-entrant context managers\n        &gt;&gt;&gt; import logging\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; def custom_write_1(text):\n        ...     logging.error(f\"[Logger 1] {text}\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; def custom_write_2(text):\n        ...     logging.error(f\"[Logger 2] {text}\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; switchable = Switchable(print)\n        &gt;&gt;&gt; with switchable.switch_to(custom_write_1):\n        ...     print(\"Message 1\")\n        ...     with switchable.switch_to(custom_write_2):\n        ...         print(\"Message 2\")\n        ...     print(\"Message 3\")\n        &gt;&gt;&gt; print(\"Message 4\")\n        ERROR:root:[Logger 1] Message 1\n        ERROR:root:[Logger 2] Message 2\n        ERROR:root:[Logger 1] Message 3\n        Message 4\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Example 3: Mocking a callable for testing\n        &gt;&gt;&gt; import random\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; def mock_random_choice(seq):\n        ...     return seq[0]  # Always return the first element\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; switchable = Switchable(random.choice)\n        &gt;&gt;&gt; with switchable.switch_to(mock_random_choice):\n        ...     print(random.choice(list(range(10))))\n        &gt;&gt;&gt; print(random.choice(list(range(10))))\n        0\n        5\n    \"\"\"\n\n    def __init__(self, target: Callable[P_Spec, T_Retval]) -&gt; None:\n        \"\"\"\n        Initialize the switchable with the given callable.\n\n        Args:\n            target: The callable to override\n        \"\"\"\n        if hasattr(target, \"__self__\"):\n            module = getmodule(parent := target.__self__)\n            variable = getattr(module, target.__name__, None)\n            if variable and id(target) == id(variable):\n                parent = module\n        else:\n            parts = target.__qualname__.split(\".\")\n            parent = getmodule(target) if len(parts) == 1 else target.__globals__.get(parts[0])\n\n        if parent is None:\n            raise ValueError(f\"Could not determine the parent object of the {target} callable\")\n\n        if isinstance(parent, ModuleType):\n            # This was an interesting edge case\n            import os\n\n            if parent.__name__ == os.name:\n                parent = os\n            elif parent.__name__ == f\"{os.name}path\":\n                parent = os.path\n\n        self._current_target = target\n        self._name = target.__name__\n        self._parent = parent\n        self._target_stack: list[Callable] = []  # For re-entrant context managers\n\n    @property\n    def original(self) -&gt; Callable[P_Spec, T_Retval]:\n        \"\"\"Access the original callable.\"\"\"\n        if self._target_stack:\n            return self._target_stack[0]\n\n        return self._current_target\n\n    def __call__(self, *args: P_Spec.args, **kwargs: P_Spec.kwargs) -&gt; T_Retval:\n        \"\"\"\n        Call the current target callable\n\n        Args:\n            args: Positional arguments\n            kwargs: Keyword arguments\n\n        Returns:\n            Return value of the original or the current target callable\n        \"\"\"\n        return self._current_target(*args, **kwargs)\n\n    @contextmanager\n    def switch_to(self, target: Callable[P_Spec, T_Retval]) -&gt; Generator[None, None, None]:\n        \"\"\"\n        Switch to another target callable temporarily.\n\n        Inside the context, you can either use the switchable instance or the\n        original callable to call the target callable.\n\n        Args:\n            target: The new target callable with same signature\n        \"\"\"\n        self._target_stack.append(self._current_target)\n        self._current_target = target\n\n        try:\n            setattr(self._parent, self._name, target)\n            yield\n        finally:\n            self._current_target = self._target_stack.pop()\n            setattr(self._parent, self._name, self._current_target)\n</code></pre>"},{"location":"sdk_reference/switchable/#cillow.switchable.Switchable.original","title":"<code>original</code>  <code>property</code>","text":"<p>Access the original callable.</p>"},{"location":"sdk_reference/switchable/#cillow.switchable.Switchable.switch_to","title":"<code>switch_to</code>","text":"<p>Switch to another target callable temporarily.</p> <p>Inside the context, you can either use the switchable instance or the original callable to call the target callable.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Callable[P_Spec, T_Retval]</code> <p>The new target callable with same signature</p> required Source code in <code>cillow/switchable.py</code> <pre><code>@contextmanager\ndef switch_to(self, target: Callable[P_Spec, T_Retval]) -&gt; Generator[None, None, None]:\n    \"\"\"\n    Switch to another target callable temporarily.\n\n    Inside the context, you can either use the switchable instance or the\n    original callable to call the target callable.\n\n    Args:\n        target: The new target callable with same signature\n    \"\"\"\n    self._target_stack.append(self._current_target)\n    self._current_target = target\n\n    try:\n        setattr(self._parent, self._name, target)\n        yield\n    finally:\n        self._current_target = self._target_stack.pop()\n        setattr(self._parent, self._name, self._current_target)\n</code></pre>"},{"location":"sdk_reference/switchable/#switch-context-manager","title":"<code>switch</code> context manager","text":"<p>Switches from one callable to another temporarily and provides access to the underlying Switchable instance. This provides both a convenient one-off switch and the ability to perform additional switches within the same context if needed.</p> <p>Parameters:</p> Name Type Description Default <code>__from</code> <code>Callable[P_Spec, T_Retval]</code> <p>The callable to switch from</p> required <code>__to</code> <code>Callable[P_Spec, T_Retval]</code> <p>The callable to switch to</p> required <p>Returns:</p> Type Description <code>None</code> <p>The Switchable instance being used for the switch</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Simple usage\n&gt;&gt;&gt; with switch(random.random, lambda: 0.42):\n...     assert random.random() == 0.42\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Advanced usage with nested switches\n&gt;&gt;&gt; with switch(random.random, lambda: 0.42) as switchable:\n...     assert random.random() == 0.42\n...     with switchable.switch_to(lambda: 0.99):\n...         assert random.random() == 0.99\n</code></pre> Source code in <code>cillow/switchable.py</code> <pre><code>@contextmanager\ndef switch(\n    __from: Callable[P_Spec, T_Retval], __to: Callable[P_Spec, T_Retval]\n) -&gt; Generator[Switchable[P_Spec, T_Retval], None, None]:\n    \"\"\"\n    Switches from one callable to another temporarily and provides access to the underlying\n    Switchable instance. This provides both a convenient one-off switch and the ability\n    to perform additional switches within the same context if needed.\n\n    Args:\n        __from: The callable to switch from\n        __to: The callable to switch to\n\n    Returns:\n        The Switchable instance being used for the switch\n\n    Examples:\n        &gt;&gt;&gt; import random\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Simple usage\n        &gt;&gt;&gt; with switch(random.random, lambda: 0.42):\n        ...     assert random.random() == 0.42\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Advanced usage with nested switches\n        &gt;&gt;&gt; with switch(random.random, lambda: 0.42) as switchable:\n        ...     assert random.random() == 0.42\n        ...     with switchable.switch_to(lambda: 0.99):\n        ...         assert random.random() == 0.99\n    \"\"\"\n    with (switchable := Switchable(__from)).switch_to(__to):\n        yield switchable\n</code></pre>"}]}